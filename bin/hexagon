#!/usr/bin/env bash
# bin/hexagon

# Ruta base del proyecto
DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

# Variables globales para manejo de procesos
SERVER_PID=""
DOCKER_COMPOSE_RUNNING=false
SERVER_MODE=false # Nueva variable para controlar cuándo estamos en modo servidor

# Función para manejar señales de interrupción
cleanup() {
  # Solo actuar si estamos en modo servidor
  if [ "$SERVER_MODE" = true ]; then
    echo
    echo -e "${YELLOW}🛑 Deteniendo servidor...${NC}"

    if [ -n "$SERVER_PID" ]; then
      kill -TERM "$SERVER_PID" 2>/dev/null
      wait "$SERVER_PID" 2>/dev/null
      SERVER_PID=""
    fi

    if [ "$DOCKER_COMPOSE_RUNNING" = true ]; then
      echo -e "${CYAN}🐳 Deteniendo Docker Compose...${NC}"
      docker-compose down 2>/dev/null
      DOCKER_COMPOSE_RUNNING=false
    fi

    echo -e "${GREEN}✅ Servidor detenido correctamente${NC}"
    SERVER_MODE=false
  else
    # Si no estamos en modo servidor, salir del programa
    echo
    echo -e "${GREEN}👋 ¡Gracias por usar Hexagonizer!${NC}"
    echo -e "${CYAN}🚀 ¡Que tengas un excelente día desarrollando!${NC}"
    exit 0
  fi
}

# Configurar traps para manejo de señales
trap cleanup SIGINT SIGTERM
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Función para mostrar el banner principal
show_banner() {
  echo -e "${PURPLE}${BOLD}"
  echo "╔══════════════════════════════════════════════════════════════════╗"
  echo "║                        🔷 HEXAGONIZER 🔷                         ║"
  echo "║                                                                  ║"
  echo "║          ⚡ Arquitectura hexagonal en segundos ⚡                ║"
  echo "║               🛠️  Clean Architecture Made Easy 🛠️                ║"
  echo "╚══════════════════════════════════════════════════════════════════╝"
  echo -e "${NC}"
  echo
}

# Función para mostrar el menú principal
show_menu() {
  echo -e "${CYAN}${BOLD}🎯 ¿Qué quieres hacer hoy?${NC}"
  echo
  echo -e "${WHITE}1.${NC} ${GREEN}🧱 Inicializar proyecto${NC} ${YELLOW}(Setup inicial)${NC}"
  echo -e "${WHITE}2.${NC} ${BLUE}🧬 Generar nueva entidad${NC} ${YELLOW}(Modo interactivo)${NC}"
  echo -e "${WHITE}3.${NC} ${PURPLE}⚡ Generar entidad rápida${NC} ${YELLOW}(Auto-aprobar todo)${NC}"
  echo -e "${WHITE}4.${NC} ${CYAN}📄 Generar desde JSON${NC} ${YELLOW}(Configuración avanzada)${NC}"
  echo -e "${WHITE}5.${NC} ${GREEN}📄⚡ JSON + Auto-aprobar${NC} ${YELLOW}(Máxima velocidad)${NC}"
  echo -e "${WHITE}6.${NC} ${BLUE}🌐 Server de desarrollo${NC} ${YELLOW}(npm start/dev)${NC}"
  echo -e "${WHITE}7.${NC} ${CYAN}📊 Estadísticas del proyecto${NC} ${YELLOW}(Info y métricas)${NC}"
  echo -e "${WHITE}8.${NC} ${RED}❌ Salir${NC}"
  echo
  echo -e "${PURPLE}${BOLD}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
}

# Función para mostrar menú de servidor
show_server_menu() {
  clear
  show_banner
  echo -e "${BLUE}${BOLD}🌐 SERVIDOR DE DESARROLLO${NC}"
  echo -e "${PURPLE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
  echo
  echo -e "${CYAN}${BOLD}🚀 Opciones Node.js:${NC}"
  echo -e "${WHITE}1.${NC} ${GREEN}⚡ npm start${NC} ${YELLOW}(Servidor producción - node src/index.js)${NC}"
  echo -e "${WHITE}2.${NC} ${BLUE}🔧 npm run dev${NC} ${YELLOW}(Desarrollo con nodemon - hot reload)${NC}"
  echo -e "${WHITE}3.${NC} ${PURPLE}🧪 npm run test${NC} ${YELLOW}(Ejecutar suite de tests)${NC}"
  echo
  echo -e "${CYAN}${BOLD}🐳 Opciones Docker:${NC}"
  echo -e "${WHITE}4.${NC} ${CYAN}🏗️  docker build -t hexagonizer .${NC} ${YELLOW}(Construir imagen)${NC}"
  echo -e "${WHITE}5.${NC} ${GREEN}🐳 docker run -p 3000:3000 hexagonizer${NC} ${YELLOW}(Ejecutar contenedor)${NC}"
  echo -e "${WHITE}6.${NC} ${BLUE}🚀 docker-compose up${NC} ${YELLOW}(Levantar con compose)${NC}"
  echo -e "${WHITE}7.${NC} ${PURPLE}🚀 docker-compose up -d${NC} ${YELLOW}(Compose en background)${NC}"
  echo -e "${WHITE}8.${NC} ${YELLOW}🛑 docker-compose down${NC} ${YELLOW}(Detener compose)${NC}"
  echo
  echo -e "${CYAN}${BOLD}🛠️  Opciones adicionales:${NC}"
  echo -e "${WHITE}9.${NC} ${GREEN}📦 npm install${NC} ${YELLOW}(Instalar dependencias)${NC}"
  echo -e "${WHITE}10.${NC} ${CYAN}🔍 npm run lint${NC} ${YELLOW}(Verificar código - si existe)${NC}"
  echo -e "${WHITE}11.${NC} ${RED}🔙 Volver al menú principal${NC}"
  echo
  echo -e "${PURPLE}${BOLD}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
}

# Función para detectar el directorio del proyecto
detect_project_dir() {
  local current_dir="$PWD"

  # Buscar package.json desde el directorio actual hacia arriba
  while [ "$current_dir" != "/" ]; do
    if [ -f "$current_dir/package.json" ]; then
      echo "$current_dir"
      return 0
    fi
    current_dir="$(dirname "$current_dir")"
  done

  # Si no se encuentra, usar el directorio actual
  echo "$PWD"
  return 1
}
run_docker_command() {
  local cmd="$1"
  local description="$2"

  echo
  echo -e "${CYAN}${BOLD}🐳 $description${NC}"
  echo -e "${PURPLE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
  echo -e "${YELLOW}📋 Ejecutando: ${BOLD}$cmd${NC}"
  echo

  # Verificar si Docker está disponible
  if ! command -v docker &>/dev/null; then
    echo -e "${RED}❌ Error: Docker no está instalado o no está en el PATH${NC}"
    echo -e "${CYAN}💡 Instala Docker para usar esta funcionalidad${NC}"
    return 1
  fi

  # Para docker-compose, verificar si existe
  if [[ "$cmd" == *"docker-compose"* ]]; then
    if ! command -v docker-compose &>/dev/null; then
      echo -e "${RED}❌ Error: docker-compose no está instalado${NC}"
      echo -e "${CYAN}💡 Instala docker-compose o usa Docker Desktop${NC}"
      return 1
    fi
  fi

  # Detectar directorio del proyecto
  local project_dir
  project_dir=$(detect_project_dir)

  echo -e "${BLUE}📂 Directorio del proyecto: ${BOLD}$project_dir${NC}"

  # Verificar archivos Docker necesarios
  local missing_files=()
  if [[ "$cmd" == *"docker build"* ]] || [[ "$cmd" == *"docker run"* ]]; then
    if [ ! -f "$project_dir/Dockerfile" ]; then
      missing_files+=("Dockerfile")
    fi
  fi

  if [[ "$cmd" == *"docker-compose"* ]]; then
    if [ ! -f "$project_dir/docker-compose.yml" ] && [ ! -f "$project_dir/docker-compose.yaml" ]; then
      missing_files+=("docker-compose.yml")
    fi
  fi

  if [ ${#missing_files[@]} -ne 0 ]; then
    echo -e "${RED}❌ Error: Archivos faltantes:${NC}"
    for file in "${missing_files[@]}"; do
      echo -e "${RED}  • $file${NC}"
    done
    echo -e "${CYAN}💡 Asegúrate de que los archivos Docker estén en la raíz del proyecto${NC}"
    return 1
  fi

  # Cambiar al directorio del proyecto
  cd "$project_dir" || {
    echo -e "${RED}❌ Error: No se pudo cambiar al directorio del proyecto${NC}"
    return 1
  }

  # Mostrar información adicional para ciertos comandos
  if [[ "$cmd" == *"docker build"* ]]; then
    echo -e "${GREEN}🏗️  Construyendo imagen Docker...${NC}"
    echo -e "${CYAN}📋 Esto puede tomar varios minutos la primera vez${NC}"
  elif [[ "$cmd" == *"docker-compose up"* ]]; then
    echo -e "${GREEN}🚀 Levantando servicios con Docker Compose...${NC}"
    echo -e "${CYAN}📋 El servidor estará disponible en http://localhost:3000${NC}"
  fi

  echo
  echo -e "${CYAN}🏃 Ejecutando comando Docker...${NC}"
  echo

  # Ejecutar el comando
  eval "$cmd"
  local exit_code=$?

  echo
  if [ $exit_code -eq 0 ]; then
    echo -e "${GREEN}✅ Comando Docker completado exitosamente${NC}"

    # Mensajes adicionales de éxito
    if [[ "$cmd" == *"docker build"* ]]; then
      echo -e "${CYAN}💡 Imagen construida. Ahora puedes ejecutarla con 'docker run'${NC}"
    elif [[ "$cmd" == *"docker-compose up -d"* ]]; then
      echo -e "${CYAN}💡 Servicios ejecutándose en background${NC}"
      echo -e "${CYAN}💡 Usa 'docker-compose logs -f' para ver los logs${NC}"
      echo -e "${CYAN}💡 Usa 'docker-compose down' para detener${NC}"
    fi
  else
    echo -e "${RED}❌ El comando Docker falló con código de salida: $exit_code${NC}"

    # Sugerencias para errores comunes
    if [[ "$cmd" == *"docker build"* ]]; then
      echo -e "${YELLOW}💡 Sugerencias:${NC}"
      echo -e "${CYAN}  • Verifica que el Dockerfile sea válido${NC}"
      echo -e "${CYAN}  • Asegúrate de tener suficiente espacio en disco${NC}"
    elif [[ "$cmd" == *"docker-compose"* ]]; then
      echo -e "${YELLOW}💡 Sugerencias:${NC}"
      echo -e "${CYAN}  • Verifica que docker-compose.yml sea válido${NC}"
      echo -e "${CYAN}  • Asegúrate de que el puerto 3000 no esté en uso${NC}"
    fi
  fi

  return $exit_code
}
detect_project_dir() {
  local current_dir="$PWD"

  # Buscar package.json desde el directorio actual hacia arriba
  while [ "$current_dir" != "/" ]; do
    if [ -f "$current_dir/package.json" ]; then
      echo "$current_dir"
      return 0
    fi
    current_dir="$(dirname "$current_dir")"
  done

  # Si no se encuentra, usar el directorio actual
  echo "$PWD"
  return 1
}

# Función para ejecutar comandos de servidor con control interactivo
run_server_command() {
  local cmd="$1"
  local description="$2"
  local is_long_running="$3" # "true" para servidores que siguen ejecutándose

  echo
  echo -e "${GREEN}${BOLD}🚀 $description${NC}"
  echo -e "${PURPLE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
  echo -e "${YELLOW}📋 Ejecutando: ${BOLD}$cmd${NC}"
  echo

  # Verificar si npm está disponible
  if ! command -v npm &>/dev/null; then
    echo -e "${RED}❌ Error: npm no está instalado o no está en el PATH${NC}"
    echo -e "${CYAN}💡 Instala Node.js y npm para usar esta funcionalidad${NC}"
    return 1
  fi

  # Detectar directorio del proyecto
  local project_dir
  project_dir=$(detect_project_dir)
  local detection_success=$?

  echo -e "${BLUE}📂 Directorio detectado: ${BOLD}$project_dir${NC}"

  # Verificar si package.json existe en el directorio detectado
  if [ ! -f "$project_dir/package.json" ]; then
    echo -e "${RED}❌ Error: No se encontró package.json en el directorio actual o superiores${NC}"
    echo -e "${CYAN}💡 Asegúrate de estar en un directorio de proyecto Node.js${NC}"
    echo -e "${YELLOW}💡 O ejecuta 'Inicializar proyecto' primero${NC}"
    return 1
  fi

  # Cambiar al directorio del proyecto
  cd "$project_dir" || {
    echo -e "${RED}❌ Error: No se pudo cambiar al directorio del proyecto${NC}"
    return 1
  }

  # Mostrar información del package.json
  if command -v node &>/dev/null; then
    local project_name
    project_name=$(node -p "require('./package.json').name" 2>/dev/null || echo "proyecto")
    echo -e "${GREEN}📦 Proyecto: ${BOLD}$project_name${NC}"
  fi

  # Verificar si el script existe antes de ejecutarlo (solo para npm run)
  local script_name="${cmd#npm run }"
  if [ "$cmd" != "npm start" ] && [ "$cmd" != "npm install" ] && [ "$script_name" != "$cmd" ]; then
    if ! npm run | grep -q "^  $script_name$" 2>/dev/null; then
      echo -e "${YELLOW}⚠️  El script '$script_name' no está definido en package.json${NC}"
      echo -e "${CYAN}📋 Scripts disponibles:${NC}"
      npm run 2>/dev/null | grep "^  " | head -10 || echo -e "${RED}  No se pudieron listar los scripts${NC}"
      return 1
    fi
  fi

  echo
  echo -e "${CYAN}🏃 Iniciando comando...${NC}"

  # Para comandos de larga duración (servidores)
  if [ "$is_long_running" = "true" ]; then
    echo -e "${PURPLE}💡 Servidor iniciándose... Presiona ${BOLD}Ctrl+C${NC}${PURPLE} para detener y volver al menú${NC}"
    echo -e "${CYAN}🌐 Una vez iniciado, estará disponible en: ${BOLD}http://localhost:3000${NC}"
    echo

    # Activar modo servidor para que Ctrl+C funcione correctamente
    SERVER_MODE=true

    # Ejecutar comando en background y capturar PID
    eval "$cmd" &
    SERVER_PID=$!

    # Esperar a que termine (por Ctrl+C o error)
    wait $SERVER_PID
    local exit_code=$?
    SERVER_PID=""

    # Desactivar modo servidor
    SERVER_MODE=false

    echo
    if [ $exit_code -eq 0 ]; then
      echo -e "${GREEN}✅ Servidor detenido correctamente${NC}"
    elif [ $exit_code -eq 130 ]; then
      echo -e "${BLUE}🔄 Servidor interrumpido por el usuario${NC}"
    else
      echo -e "${RED}❌ El servidor terminó con código de salida: $exit_code${NC}"
    fi

  else
    # Para comandos de corta duración (install, test, etc.)
    eval "$cmd"
    local exit_code=$?

    echo
    if [ $exit_code -eq 0 ]; then
      echo -e "${GREEN}✅ Comando completado exitosamente${NC}"
    else
      echo -e "${RED}❌ El comando falló con código de salida: $exit_code${NC}"

      # Sugerir alternativas comunes
      if [ "$script_name" = "dev" ] && [ $exit_code -eq 1 ]; then
        echo -e "${YELLOW}💡 Sugerencias:${NC}"
        echo -e "${CYAN}  • Prueba con 'npm start' si no tienes script dev${NC}"
        echo -e "${CYAN}  • Agrega un script dev a tu package.json${NC}"
        echo -e "${CYAN}  • Verifica que las dependencias estén instaladas${NC}"
      fi
    fi
  fi

  return $exit_code
}

# Función para mostrar estadísticas del proyecto
show_project_stats() {
  clear
  show_banner
  echo -e "${YELLOW}${BOLD}📊 ESTADÍSTICAS DEL PROYECTO${NC}"
  echo -e "${PURPLE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
  echo

  # Detectar directorio del proyecto
  local project_dir
  project_dir=$(detect_project_dir)
  echo -e "${BLUE}📂 Analizando proyecto en: ${BOLD}$project_dir${NC}"
  echo

  # Información básica del proyecto
  if [ -f "$project_dir/package.json" ]; then
    echo -e "${GREEN}📦 Proyecto configurado correctamente${NC}"

    # Extraer nombre del proyecto si existe
    if command -v node &>/dev/null; then
      cd "$project_dir"
      project_name=$(node -p "require('./package.json').name" 2>/dev/null || echo "N/A")
      project_version=$(node -p "require('./package.json').version" 2>/dev/null || echo "N/A")
      echo -e "${CYAN}📋 Nombre: ${BOLD}$project_name${NC}"
      echo -e "${CYAN}🏷️  Versión: ${BOLD}$project_version${NC}"
    fi
  else
    echo -e "${RED}❌ Proyecto no inicializado (falta package.json)${NC}"
    echo -e "${YELLOW}💡 Ejecuta desde un directorio con proyecto Node.js${NC}"
  fi

  echo

  # Estadísticas de archivos y estructura
  if [ -d "$project_dir/src" ]; then
    echo -e "${BLUE}📁 Estructura del proyecto:${NC}"

    # Contar entidades en domain
    if [ -d "$project_dir/src/domain" ]; then
      entity_count=$(find "$project_dir/src/domain" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | wc -l)
      echo -e "${GREEN}  🏗️  Entidades generadas: ${BOLD}$entity_count${NC}"

      if [ "$entity_count" -gt 0 ]; then
        echo -e "${PURPLE}  📝 Entidades encontradas:${NC}"
        find "$project_dir/src/domain" -mindepth 1 -maxdepth 1 -type d -exec basename {} \; 2>/dev/null | while read -r entity; do
          echo -e "${CYAN}    • $entity${NC}"
        done
      fi
    fi

    # Contar archivos de código
    js_files=$(find "$project_dir/src" -name "*.js" 2>/dev/null | wc -l)
    ts_files=$(find "$project_dir/src" -name "*.ts" 2>/dev/null | wc -l)
    total_files=$((js_files + ts_files))

    echo -e "${YELLOW}  📄 Archivos JavaScript: ${BOLD}$js_files${NC}"
    echo -e "${YELLOW}  📄 Archivos TypeScript: ${BOLD}$ts_files${NC}"
    echo -e "${WHITE}  📊 Total archivos de código: ${BOLD}$total_files${NC}"

    # Contar tests
    if [ -d "$project_dir/tests" ] || [ -d "$project_dir/test" ] || [ -d "$project_dir/__tests__" ]; then
      test_files=$(find "$project_dir" -name "*.test.js" -o -name "*.test.ts" -o -name "*.spec.js" -o -name "*.spec.ts" 2>/dev/null | wc -l)
      echo -e "${GREEN}  🧪 Archivos de test: ${BOLD}$test_files${NC}"
    fi

  else
    echo -e "${RED}📁 Directorio src no encontrado${NC}"
  fi

  echo

  # Información de dependencias
  if [ -f "$project_dir/package.json" ] && command -v npm &>/dev/null; then
    echo -e "${CYAN}📦 Información de dependencias:${NC}"
    cd "$project_dir"

    # Verificar node_modules
    if [ -d "node_modules" ]; then
      echo -e "${GREEN}  ✅ node_modules instalado${NC}"

      # Contar dependencias instaladas
      if [ -f "package-lock.json" ]; then
        deps_count=$(npm list --depth=0 --silent 2>/dev/null | grep -c "├\|└" || echo "0")
        echo -e "${BLUE}  📊 Dependencias instaladas: ${BOLD}$deps_count${NC}"
      fi
    else
      echo -e "${YELLOW}  ⚠️  node_modules no encontrado${NC}"
      echo -e "${PURPLE}    💡 Ejecuta 'npm install' para instalar dependencias${NC}"
    fi
  fi

  # Mostrar estructura básica si está disponible
  echo
  echo -e "${CYAN}🗂️  Estructura de directorios:${NC}"
  if command -v tree &>/dev/null; then
    tree "$project_dir/src" -L 2 -I 'node_modules' 2>/dev/null || echo -e "${YELLOW}  📂 src/ (usar tree para ver estructura detallada)${NC}"
  else
    if [ -d "$project_dir/src" ]; then
      ls -la "$project_dir/src" | grep ^d | awk '{print "  📂 " $9}' 2>/dev/null || echo -e "${YELLOW}  📂 src/ directory exists${NC}"
    fi
  fi
}

# Función para leer opción del menú principal
read_option() {
  local choice
  echo -e "${WHITE}👉 Selecciona una opción [1-8]: ${NC}"
  read -r choice

  case "$choice" in
  1)
    echo -e "${GREEN}🧱 Inicializando proyecto...${NC}"
    bash "$DIR/scripts/init-project.sh"
    ;;
  2)
    echo -e "${BLUE}🧬 Generador interactivo de entidades...${NC}"
    bash "$DIR/scripts/entity-generator.sh"
    ;;
  3)
    echo -e "${PURPLE}⚡ Generación rápida (auto-aprobar)...${NC}"
    bash "$DIR/scripts/entity-generator.sh" -y
    ;;
  4)
    echo -e "${CYAN}📄 Generando desde archivo JSON...${NC}"
    bash "$DIR/scripts/entity-generator.sh" --json
    ;;
  5)
    echo -e "${GREEN}📄⚡ JSON + Auto-aprobar...${NC}"
    bash "$DIR/scripts/entity-generator.sh" --json -y
    ;;
  6)
    handle_server_menu
    return
    ;;
  7)
    show_project_stats
    ;;
  8)
    echo -e "${GREEN}👋 ¡Gracias por usar Hexagonizer!${NC}"
    echo -e "${CYAN}🚀 ¡Que tengas un excelente día desarrollando!${NC}"
    exit 0
    ;;
  *)
    echo -e "${RED}❌ Opción inválida. Por favor selecciona 1-8.${NC}"
    ;;
  esac

  echo
  echo -e "${WHITE}Presiona ENTER para continuar...${NC}"
  read -r
}

# Función para manejar el menú de servidor
handle_server_menu() {
  while true; do
    show_server_menu
    echo -e "${WHITE}👉 Selecciona una opción [1-11]: ${NC}"
    read -r server_choice

    case "$server_choice" in
    1)
      run_server_command "npm start" "Iniciando servidor de producción" "true"
      ;;
    2)
      run_server_command "npm run dev" "Iniciando servidor de desarrollo con nodemon" "true"
      ;;
    3)
      run_server_command "npm run test" "Ejecutando suite de tests" "false"
      ;;
    4)
      run_docker_command "docker build -t hexagonizer ." "Construyendo imagen Docker" "false"
      ;;
    5)
      run_docker_command "docker run -p 3000:3000 hexagonizer" "Ejecutando contenedor Docker" "true"
      ;;
    6)
      run_docker_command "docker-compose up" "Levantando servicios con Docker Compose" "true"
      ;;
    7)
      run_docker_command "docker-compose up -d" "Levantando servicios en background" "false"
      ;;
    8)
      run_docker_command "docker-compose down" "Deteniendo servicios Docker Compose" "false"
      ;;
    9)
      run_server_command "npm install" "Instalando dependencias npm" "false"
      ;;
    10)
      run_server_command "npm run lint" "Verificando calidad del código" "false"
      ;;
    11)
      echo -e "${BLUE}🔙 Volviendo al menú principal...${NC}"
      return
      ;;
    *)
      echo -e "${RED}❌ Opción inválida. Por favor selecciona 1-11.${NC}"
      ;;
    esac

    # Solo pausar para comandos que no son de larga duración o cuando fallan
    if [ "$server_choice" != "11" ]; then
      # No pausar después de comandos de servidor que se interrumpieron correctamente
      if [[ "$server_choice" =~ ^[125678]$ ]]; then
        # Para comandos de larga duración o comandos de Docker que terminaron
        echo
        echo -e "${WHITE}Presiona ENTER para continuar...${NC}"
        read -r
      elif [[ "$server_choice" =~ ^[34910]$ ]]; then
        # Para comandos de corta duración
        echo
        echo -e "${WHITE}Presiona ENTER para continuar...${NC}"
        read -r
      fi
    fi
  done
}

# Bucle principal
main() {
  while true; do
    clear
    show_banner
    show_menu
    read_option
  done
}

# Ejecutar programa principal
main
