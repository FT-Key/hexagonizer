#!/usr/bin/env bash
# bin/hexagon

# Ruta base del proyecto
DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

# Variables globales para manejo de procesos
SERVER_PID=""
DOCKER_COMPOSE_RUNNING=false
SERVER_MODE=false # Nueva variable para controlar cu√°ndo estamos en modo servidor

# Funci√≥n para manejar se√±ales de interrupci√≥n
cleanup() {
  # Solo actuar si estamos en modo servidor
  if [ "$SERVER_MODE" = true ]; then
    echo
    echo -e "${YELLOW}üõë Deteniendo servidor...${NC}"

    if [ -n "$SERVER_PID" ]; then
      kill -TERM "$SERVER_PID" 2>/dev/null
      wait "$SERVER_PID" 2>/dev/null
      SERVER_PID=""
    fi

    if [ "$DOCKER_COMPOSE_RUNNING" = true ]; then
      echo -e "${CYAN}üê≥ Deteniendo Docker Compose...${NC}"
      docker-compose down 2>/dev/null
      DOCKER_COMPOSE_RUNNING=false
    fi

    echo -e "${GREEN}‚úÖ Servidor detenido correctamente${NC}"
    SERVER_MODE=false
  else
    # Si no estamos en modo servidor, salir del programa
    echo
    echo -e "${GREEN}üëã ¬°Gracias por usar Hexagonizer!${NC}"
    echo -e "${CYAN}üöÄ ¬°Que tengas un excelente d√≠a desarrollando!${NC}"
    exit 0
  fi
}

# Configurar traps para manejo de se√±ales
trap cleanup SIGINT SIGTERM
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Funci√≥n para mostrar el banner principal
show_banner() {
  echo -e "${PURPLE}${BOLD}"
  echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
  echo "‚ïë                        üî∑ HEXAGONIZER üî∑                         ‚ïë"
  echo "‚ïë                                                                  ‚ïë"
  echo "‚ïë          ‚ö° Arquitectura hexagonal en segundos ‚ö°                ‚ïë"
  echo "‚ïë               üõ†Ô∏è  Clean Architecture Made Easy üõ†Ô∏è                ‚ïë"
  echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
  echo -e "${NC}"
  echo
}

# Funci√≥n para mostrar el men√∫ principal
show_menu() {
  echo -e "${CYAN}${BOLD}üéØ ¬øQu√© quieres hacer hoy?${NC}"
  echo
  echo -e "${WHITE}1.${NC} ${GREEN}üß± Inicializar proyecto${NC} ${YELLOW}(Setup inicial)${NC}"
  echo -e "${WHITE}2.${NC} ${BLUE}üß¨ Generar nueva entidad${NC} ${YELLOW}(Modo interactivo)${NC}"
  echo -e "${WHITE}3.${NC} ${PURPLE}‚ö° Generar entidad r√°pida${NC} ${YELLOW}(Auto-aprobar todo)${NC}"
  echo -e "${WHITE}4.${NC} ${CYAN}üìÑ Generar desde JSON${NC} ${YELLOW}(Configuraci√≥n avanzada)${NC}"
  echo -e "${WHITE}5.${NC} ${GREEN}üìÑ‚ö° JSON + Auto-aprobar${NC} ${YELLOW}(M√°xima velocidad)${NC}"
  echo -e "${WHITE}6.${NC} ${BLUE}üåê Server de desarrollo${NC} ${YELLOW}(npm start/dev)${NC}"
  echo -e "${WHITE}7.${NC} ${CYAN}üìä Estad√≠sticas del proyecto${NC} ${YELLOW}(Info y m√©tricas)${NC}"
  echo -e "${WHITE}8.${NC} ${RED}‚ùå Salir${NC}"
  echo
  echo -e "${PURPLE}${BOLD}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
}

# Funci√≥n para mostrar men√∫ de servidor
show_server_menu() {
  clear
  show_banner
  echo -e "${BLUE}${BOLD}üåê SERVIDOR DE DESARROLLO${NC}"
  echo -e "${PURPLE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
  echo
  echo -e "${CYAN}${BOLD}üöÄ Opciones Node.js:${NC}"
  echo -e "${WHITE}1.${NC} ${GREEN}‚ö° npm start${NC} ${YELLOW}(Servidor producci√≥n - node src/index.js)${NC}"
  echo -e "${WHITE}2.${NC} ${BLUE}üîß npm run dev${NC} ${YELLOW}(Desarrollo con nodemon - hot reload)${NC}"
  echo -e "${WHITE}3.${NC} ${PURPLE}üß™ npm run test${NC} ${YELLOW}(Ejecutar suite de tests)${NC}"
  echo
  echo -e "${CYAN}${BOLD}üê≥ Opciones Docker:${NC}"
  echo -e "${WHITE}4.${NC} ${CYAN}üèóÔ∏è  docker build -t hexagonizer .${NC} ${YELLOW}(Construir imagen)${NC}"
  echo -e "${WHITE}5.${NC} ${GREEN}üê≥ docker run -p 3000:3000 hexagonizer${NC} ${YELLOW}(Ejecutar contenedor)${NC}"
  echo -e "${WHITE}6.${NC} ${BLUE}üöÄ docker-compose up${NC} ${YELLOW}(Levantar con compose)${NC}"
  echo -e "${WHITE}7.${NC} ${PURPLE}üöÄ docker-compose up -d${NC} ${YELLOW}(Compose en background)${NC}"
  echo -e "${WHITE}8.${NC} ${YELLOW}üõë docker-compose down${NC} ${YELLOW}(Detener compose)${NC}"
  echo
  echo -e "${CYAN}${BOLD}üõ†Ô∏è  Opciones adicionales:${NC}"
  echo -e "${WHITE}9.${NC} ${GREEN}üì¶ npm install${NC} ${YELLOW}(Instalar dependencias)${NC}"
  echo -e "${WHITE}10.${NC} ${CYAN}üîç npm run lint${NC} ${YELLOW}(Verificar c√≥digo - si existe)${NC}"
  echo -e "${WHITE}11.${NC} ${RED}üîô Volver al men√∫ principal${NC}"
  echo
  echo -e "${PURPLE}${BOLD}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
}

# Funci√≥n para detectar el directorio del proyecto
detect_project_dir() {
  local current_dir="$PWD"

  # Buscar package.json desde el directorio actual hacia arriba
  while [ "$current_dir" != "/" ]; do
    if [ -f "$current_dir/package.json" ]; then
      echo "$current_dir"
      return 0
    fi
    current_dir="$(dirname "$current_dir")"
  done

  # Si no se encuentra, usar el directorio actual
  echo "$PWD"
  return 1
}
run_docker_command() {
  local cmd="$1"
  local description="$2"

  echo
  echo -e "${CYAN}${BOLD}üê≥ $description${NC}"
  echo -e "${PURPLE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
  echo -e "${YELLOW}üìã Ejecutando: ${BOLD}$cmd${NC}"
  echo

  # Verificar si Docker est√° disponible
  if ! command -v docker &>/dev/null; then
    echo -e "${RED}‚ùå Error: Docker no est√° instalado o no est√° en el PATH${NC}"
    echo -e "${CYAN}üí° Instala Docker para usar esta funcionalidad${NC}"
    return 1
  fi

  # Para docker-compose, verificar si existe
  if [[ "$cmd" == *"docker-compose"* ]]; then
    if ! command -v docker-compose &>/dev/null; then
      echo -e "${RED}‚ùå Error: docker-compose no est√° instalado${NC}"
      echo -e "${CYAN}üí° Instala docker-compose o usa Docker Desktop${NC}"
      return 1
    fi
  fi

  # Detectar directorio del proyecto
  local project_dir
  project_dir=$(detect_project_dir)

  echo -e "${BLUE}üìÇ Directorio del proyecto: ${BOLD}$project_dir${NC}"

  # Verificar archivos Docker necesarios
  local missing_files=()
  if [[ "$cmd" == *"docker build"* ]] || [[ "$cmd" == *"docker run"* ]]; then
    if [ ! -f "$project_dir/Dockerfile" ]; then
      missing_files+=("Dockerfile")
    fi
  fi

  if [[ "$cmd" == *"docker-compose"* ]]; then
    if [ ! -f "$project_dir/docker-compose.yml" ] && [ ! -f "$project_dir/docker-compose.yaml" ]; then
      missing_files+=("docker-compose.yml")
    fi
  fi

  if [ ${#missing_files[@]} -ne 0 ]; then
    echo -e "${RED}‚ùå Error: Archivos faltantes:${NC}"
    for file in "${missing_files[@]}"; do
      echo -e "${RED}  ‚Ä¢ $file${NC}"
    done
    echo -e "${CYAN}üí° Aseg√∫rate de que los archivos Docker est√©n en la ra√≠z del proyecto${NC}"
    return 1
  fi

  # Cambiar al directorio del proyecto
  cd "$project_dir" || {
    echo -e "${RED}‚ùå Error: No se pudo cambiar al directorio del proyecto${NC}"
    return 1
  }

  # Mostrar informaci√≥n adicional para ciertos comandos
  if [[ "$cmd" == *"docker build"* ]]; then
    echo -e "${GREEN}üèóÔ∏è  Construyendo imagen Docker...${NC}"
    echo -e "${CYAN}üìã Esto puede tomar varios minutos la primera vez${NC}"
  elif [[ "$cmd" == *"docker-compose up"* ]]; then
    echo -e "${GREEN}üöÄ Levantando servicios con Docker Compose...${NC}"
    echo -e "${CYAN}üìã El servidor estar√° disponible en http://localhost:3000${NC}"
  fi

  echo
  echo -e "${CYAN}üèÉ Ejecutando comando Docker...${NC}"
  echo

  # Ejecutar el comando
  eval "$cmd"
  local exit_code=$?

  echo
  if [ $exit_code -eq 0 ]; then
    echo -e "${GREEN}‚úÖ Comando Docker completado exitosamente${NC}"

    # Mensajes adicionales de √©xito
    if [[ "$cmd" == *"docker build"* ]]; then
      echo -e "${CYAN}üí° Imagen construida. Ahora puedes ejecutarla con 'docker run'${NC}"
    elif [[ "$cmd" == *"docker-compose up -d"* ]]; then
      echo -e "${CYAN}üí° Servicios ejecut√°ndose en background${NC}"
      echo -e "${CYAN}üí° Usa 'docker-compose logs -f' para ver los logs${NC}"
      echo -e "${CYAN}üí° Usa 'docker-compose down' para detener${NC}"
    fi
  else
    echo -e "${RED}‚ùå El comando Docker fall√≥ con c√≥digo de salida: $exit_code${NC}"

    # Sugerencias para errores comunes
    if [[ "$cmd" == *"docker build"* ]]; then
      echo -e "${YELLOW}üí° Sugerencias:${NC}"
      echo -e "${CYAN}  ‚Ä¢ Verifica que el Dockerfile sea v√°lido${NC}"
      echo -e "${CYAN}  ‚Ä¢ Aseg√∫rate de tener suficiente espacio en disco${NC}"
    elif [[ "$cmd" == *"docker-compose"* ]]; then
      echo -e "${YELLOW}üí° Sugerencias:${NC}"
      echo -e "${CYAN}  ‚Ä¢ Verifica que docker-compose.yml sea v√°lido${NC}"
      echo -e "${CYAN}  ‚Ä¢ Aseg√∫rate de que el puerto 3000 no est√© en uso${NC}"
    fi
  fi

  return $exit_code
}
detect_project_dir() {
  local current_dir="$PWD"

  # Buscar package.json desde el directorio actual hacia arriba
  while [ "$current_dir" != "/" ]; do
    if [ -f "$current_dir/package.json" ]; then
      echo "$current_dir"
      return 0
    fi
    current_dir="$(dirname "$current_dir")"
  done

  # Si no se encuentra, usar el directorio actual
  echo "$PWD"
  return 1
}

# Funci√≥n para ejecutar comandos de servidor con control interactivo
run_server_command() {
  local cmd="$1"
  local description="$2"
  local is_long_running="$3" # "true" para servidores que siguen ejecut√°ndose

  echo
  echo -e "${GREEN}${BOLD}üöÄ $description${NC}"
  echo -e "${PURPLE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
  echo -e "${YELLOW}üìã Ejecutando: ${BOLD}$cmd${NC}"
  echo

  # Verificar si npm est√° disponible
  if ! command -v npm &>/dev/null; then
    echo -e "${RED}‚ùå Error: npm no est√° instalado o no est√° en el PATH${NC}"
    echo -e "${CYAN}üí° Instala Node.js y npm para usar esta funcionalidad${NC}"
    return 1
  fi

  # Detectar directorio del proyecto
  local project_dir
  project_dir=$(detect_project_dir)
  local detection_success=$?

  echo -e "${BLUE}üìÇ Directorio detectado: ${BOLD}$project_dir${NC}"

  # Verificar si package.json existe en el directorio detectado
  if [ ! -f "$project_dir/package.json" ]; then
    echo -e "${RED}‚ùå Error: No se encontr√≥ package.json en el directorio actual o superiores${NC}"
    echo -e "${CYAN}üí° Aseg√∫rate de estar en un directorio de proyecto Node.js${NC}"
    echo -e "${YELLOW}üí° O ejecuta 'Inicializar proyecto' primero${NC}"
    return 1
  fi

  # Cambiar al directorio del proyecto
  cd "$project_dir" || {
    echo -e "${RED}‚ùå Error: No se pudo cambiar al directorio del proyecto${NC}"
    return 1
  }

  # Mostrar informaci√≥n del package.json
  if command -v node &>/dev/null; then
    local project_name
    project_name=$(node -p "require('./package.json').name" 2>/dev/null || echo "proyecto")
    echo -e "${GREEN}üì¶ Proyecto: ${BOLD}$project_name${NC}"
  fi

  # Verificar si el script existe antes de ejecutarlo (solo para npm run)
  local script_name="${cmd#npm run }"
  if [ "$cmd" != "npm start" ] && [ "$cmd" != "npm install" ] && [ "$script_name" != "$cmd" ]; then
    if ! npm run | grep -q "^  $script_name$" 2>/dev/null; then
      echo -e "${YELLOW}‚ö†Ô∏è  El script '$script_name' no est√° definido en package.json${NC}"
      echo -e "${CYAN}üìã Scripts disponibles:${NC}"
      npm run 2>/dev/null | grep "^  " | head -10 || echo -e "${RED}  No se pudieron listar los scripts${NC}"
      return 1
    fi
  fi

  echo
  echo -e "${CYAN}üèÉ Iniciando comando...${NC}"

  # Para comandos de larga duraci√≥n (servidores)
  if [ "$is_long_running" = "true" ]; then
    echo -e "${PURPLE}üí° Servidor inici√°ndose... Presiona ${BOLD}Ctrl+C${NC}${PURPLE} para detener y volver al men√∫${NC}"
    echo -e "${CYAN}üåê Una vez iniciado, estar√° disponible en: ${BOLD}http://localhost:3000${NC}"
    echo

    # Activar modo servidor para que Ctrl+C funcione correctamente
    SERVER_MODE=true

    # Ejecutar comando en background y capturar PID
    eval "$cmd" &
    SERVER_PID=$!

    # Esperar a que termine (por Ctrl+C o error)
    wait $SERVER_PID
    local exit_code=$?
    SERVER_PID=""

    # Desactivar modo servidor
    SERVER_MODE=false

    echo
    if [ $exit_code -eq 0 ]; then
      echo -e "${GREEN}‚úÖ Servidor detenido correctamente${NC}"
    elif [ $exit_code -eq 130 ]; then
      echo -e "${BLUE}üîÑ Servidor interrumpido por el usuario${NC}"
    else
      echo -e "${RED}‚ùå El servidor termin√≥ con c√≥digo de salida: $exit_code${NC}"
    fi

  else
    # Para comandos de corta duraci√≥n (install, test, etc.)
    eval "$cmd"
    local exit_code=$?

    echo
    if [ $exit_code -eq 0 ]; then
      echo -e "${GREEN}‚úÖ Comando completado exitosamente${NC}"
    else
      echo -e "${RED}‚ùå El comando fall√≥ con c√≥digo de salida: $exit_code${NC}"

      # Sugerir alternativas comunes
      if [ "$script_name" = "dev" ] && [ $exit_code -eq 1 ]; then
        echo -e "${YELLOW}üí° Sugerencias:${NC}"
        echo -e "${CYAN}  ‚Ä¢ Prueba con 'npm start' si no tienes script dev${NC}"
        echo -e "${CYAN}  ‚Ä¢ Agrega un script dev a tu package.json${NC}"
        echo -e "${CYAN}  ‚Ä¢ Verifica que las dependencias est√©n instaladas${NC}"
      fi
    fi
  fi

  return $exit_code
}

# Funci√≥n para mostrar estad√≠sticas del proyecto
show_project_stats() {
  clear
  show_banner
  echo -e "${YELLOW}${BOLD}üìä ESTAD√çSTICAS DEL PROYECTO${NC}"
  echo -e "${PURPLE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
  echo

  # Detectar directorio del proyecto
  local project_dir
  project_dir=$(detect_project_dir)
  echo -e "${BLUE}üìÇ Analizando proyecto en: ${BOLD}$project_dir${NC}"
  echo

  # Informaci√≥n b√°sica del proyecto
  if [ -f "$project_dir/package.json" ]; then
    echo -e "${GREEN}üì¶ Proyecto configurado correctamente${NC}"

    # Extraer nombre del proyecto si existe
    if command -v node &>/dev/null; then
      cd "$project_dir"
      project_name=$(node -p "require('./package.json').name" 2>/dev/null || echo "N/A")
      project_version=$(node -p "require('./package.json').version" 2>/dev/null || echo "N/A")
      echo -e "${CYAN}üìã Nombre: ${BOLD}$project_name${NC}"
      echo -e "${CYAN}üè∑Ô∏è  Versi√≥n: ${BOLD}$project_version${NC}"
    fi
  else
    echo -e "${RED}‚ùå Proyecto no inicializado (falta package.json)${NC}"
    echo -e "${YELLOW}üí° Ejecuta desde un directorio con proyecto Node.js${NC}"
  fi

  echo

  # Estad√≠sticas de archivos y estructura
  if [ -d "$project_dir/src" ]; then
    echo -e "${BLUE}üìÅ Estructura del proyecto:${NC}"

    # Contar entidades en domain
    if [ -d "$project_dir/src/domain" ]; then
      entity_count=$(find "$project_dir/src/domain" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | wc -l)
      echo -e "${GREEN}  üèóÔ∏è  Entidades generadas: ${BOLD}$entity_count${NC}"

      if [ "$entity_count" -gt 0 ]; then
        echo -e "${PURPLE}  üìù Entidades encontradas:${NC}"
        find "$project_dir/src/domain" -mindepth 1 -maxdepth 1 -type d -exec basename {} \; 2>/dev/null | while read -r entity; do
          echo -e "${CYAN}    ‚Ä¢ $entity${NC}"
        done
      fi
    fi

    # Contar archivos de c√≥digo
    js_files=$(find "$project_dir/src" -name "*.js" 2>/dev/null | wc -l)
    ts_files=$(find "$project_dir/src" -name "*.ts" 2>/dev/null | wc -l)
    total_files=$((js_files + ts_files))

    echo -e "${YELLOW}  üìÑ Archivos JavaScript: ${BOLD}$js_files${NC}"
    echo -e "${YELLOW}  üìÑ Archivos TypeScript: ${BOLD}$ts_files${NC}"
    echo -e "${WHITE}  üìä Total archivos de c√≥digo: ${BOLD}$total_files${NC}"

    # Contar tests
    if [ -d "$project_dir/tests" ] || [ -d "$project_dir/test" ] || [ -d "$project_dir/__tests__" ]; then
      test_files=$(find "$project_dir" -name "*.test.js" -o -name "*.test.ts" -o -name "*.spec.js" -o -name "*.spec.ts" 2>/dev/null | wc -l)
      echo -e "${GREEN}  üß™ Archivos de test: ${BOLD}$test_files${NC}"
    fi

  else
    echo -e "${RED}üìÅ Directorio src no encontrado${NC}"
  fi

  echo

  # Informaci√≥n de dependencias
  if [ -f "$project_dir/package.json" ] && command -v npm &>/dev/null; then
    echo -e "${CYAN}üì¶ Informaci√≥n de dependencias:${NC}"
    cd "$project_dir"

    # Verificar node_modules
    if [ -d "node_modules" ]; then
      echo -e "${GREEN}  ‚úÖ node_modules instalado${NC}"

      # Contar dependencias instaladas
      if [ -f "package-lock.json" ]; then
        deps_count=$(npm list --depth=0 --silent 2>/dev/null | grep -c "‚îú\|‚îî" || echo "0")
        echo -e "${BLUE}  üìä Dependencias instaladas: ${BOLD}$deps_count${NC}"
      fi
    else
      echo -e "${YELLOW}  ‚ö†Ô∏è  node_modules no encontrado${NC}"
      echo -e "${PURPLE}    üí° Ejecuta 'npm install' para instalar dependencias${NC}"
    fi
  fi

  # Mostrar estructura b√°sica si est√° disponible
  echo
  echo -e "${CYAN}üóÇÔ∏è  Estructura de directorios:${NC}"
  if command -v tree &>/dev/null; then
    tree "$project_dir/src" -L 2 -I 'node_modules' 2>/dev/null || echo -e "${YELLOW}  üìÇ src/ (usar tree para ver estructura detallada)${NC}"
  else
    if [ -d "$project_dir/src" ]; then
      ls -la "$project_dir/src" | grep ^d | awk '{print "  üìÇ " $9}' 2>/dev/null || echo -e "${YELLOW}  üìÇ src/ directory exists${NC}"
    fi
  fi
}

# Funci√≥n para leer opci√≥n del men√∫ principal
read_option() {
  local choice
  echo -e "${WHITE}üëâ Selecciona una opci√≥n [1-8]: ${NC}"
  read -r choice

  case "$choice" in
  1)
    echo -e "${GREEN}üß± Inicializando proyecto...${NC}"
    bash "$DIR/scripts/init-project.sh"
    ;;
  2)
    echo -e "${BLUE}üß¨ Generador interactivo de entidades...${NC}"
    bash "$DIR/scripts/entity-generator.sh"
    ;;
  3)
    echo -e "${PURPLE}‚ö° Generaci√≥n r√°pida (auto-aprobar)...${NC}"
    bash "$DIR/scripts/entity-generator.sh" -y
    ;;
  4)
    echo -e "${CYAN}üìÑ Generando desde archivo JSON...${NC}"
    bash "$DIR/scripts/entity-generator.sh" --json
    ;;
  5)
    echo -e "${GREEN}üìÑ‚ö° JSON + Auto-aprobar...${NC}"
    bash "$DIR/scripts/entity-generator.sh" --json -y
    ;;
  6)
    handle_server_menu
    return
    ;;
  7)
    show_project_stats
    ;;
  8)
    echo -e "${GREEN}üëã ¬°Gracias por usar Hexagonizer!${NC}"
    echo -e "${CYAN}üöÄ ¬°Que tengas un excelente d√≠a desarrollando!${NC}"
    exit 0
    ;;
  *)
    echo -e "${RED}‚ùå Opci√≥n inv√°lida. Por favor selecciona 1-8.${NC}"
    ;;
  esac

  echo
  echo -e "${WHITE}Presiona ENTER para continuar...${NC}"
  read -r
}

# Funci√≥n para manejar el men√∫ de servidor
handle_server_menu() {
  while true; do
    show_server_menu
    echo -e "${WHITE}üëâ Selecciona una opci√≥n [1-11]: ${NC}"
    read -r server_choice

    case "$server_choice" in
    1)
      run_server_command "npm start" "Iniciando servidor de producci√≥n" "true"
      ;;
    2)
      run_server_command "npm run dev" "Iniciando servidor de desarrollo con nodemon" "true"
      ;;
    3)
      run_server_command "npm run test" "Ejecutando suite de tests" "false"
      ;;
    4)
      run_docker_command "docker build -t hexagonizer ." "Construyendo imagen Docker" "false"
      ;;
    5)
      run_docker_command "docker run -p 3000:3000 hexagonizer" "Ejecutando contenedor Docker" "true"
      ;;
    6)
      run_docker_command "docker-compose up" "Levantando servicios con Docker Compose" "true"
      ;;
    7)
      run_docker_command "docker-compose up -d" "Levantando servicios en background" "false"
      ;;
    8)
      run_docker_command "docker-compose down" "Deteniendo servicios Docker Compose" "false"
      ;;
    9)
      run_server_command "npm install" "Instalando dependencias npm" "false"
      ;;
    10)
      run_server_command "npm run lint" "Verificando calidad del c√≥digo" "false"
      ;;
    11)
      echo -e "${BLUE}üîô Volviendo al men√∫ principal...${NC}"
      return
      ;;
    *)
      echo -e "${RED}‚ùå Opci√≥n inv√°lida. Por favor selecciona 1-11.${NC}"
      ;;
    esac

    # Solo pausar para comandos que no son de larga duraci√≥n o cuando fallan
    if [ "$server_choice" != "11" ]; then
      # No pausar despu√©s de comandos de servidor que se interrumpieron correctamente
      if [[ "$server_choice" =~ ^[125678]$ ]]; then
        # Para comandos de larga duraci√≥n o comandos de Docker que terminaron
        echo
        echo -e "${WHITE}Presiona ENTER para continuar...${NC}"
        read -r
      elif [[ "$server_choice" =~ ^[34910]$ ]]; then
        # Para comandos de corta duraci√≥n
        echo
        echo -e "${WHITE}Presiona ENTER para continuar...${NC}"
        read -r
      fi
    fi
  done
}

# Bucle principal
main() {
  while true; do
    clear
    show_banner
    show_menu
    read_option
  done
}

# Ejecutar programa principal
main
